/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasIconsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  iconSize: 64,
  recentIcons: [],
  maxRecentIcons: 20
};
var POPULAR_ICONS = [
  "star",
  "heart",
  "check",
  "x",
  "plus",
  "minus",
  "arrow-right",
  "arrow-left",
  "arrow-up",
  "arrow-down",
  "folder",
  "file",
  "file-text",
  "image",
  "link",
  "tag",
  "bookmark",
  "calendar",
  "clock",
  "bell",
  "user",
  "users",
  "settings",
  "search",
  "home",
  "mail",
  "message-circle",
  "phone",
  "map-pin",
  "globe",
  "sun",
  "moon",
  "cloud",
  "zap",
  "flame",
  "target",
  "flag",
  "award",
  "gift",
  "coffee",
  "book",
  "pen",
  "pencil",
  "highlighter",
  "eraser",
  "scissors",
  "copy",
  "clipboard",
  "trash",
  "archive",
  "download",
  "upload",
  "share",
  "external-link",
  "refresh-cw",
  "play",
  "pause",
  "stop-circle",
  "skip-forward",
  "skip-back",
  "volume-2",
  "mic",
  "camera",
  "video",
  "monitor",
  "smartphone",
  "tablet",
  "laptop",
  "cpu",
  "database",
  "code",
  "terminal",
  "git-branch",
  "git-commit",
  "git-merge",
  "lock",
  "unlock",
  "key",
  "shield",
  "eye",
  "alert-circle",
  "info",
  "help-circle",
  "check-circle",
  "x-circle",
  "lightbulb",
  "compass",
  "map",
  "navigation",
  "anchor"
];
var CanvasIconsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.toolbarButton = null;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "add-icon-to-canvas",
      name: "Add icon to Canvas",
      checkCallback: (checking) => {
        const canvasView = this.getActiveCanvasView();
        if (canvasView) {
          if (!checking) {
            this.openIconPicker(canvasView.canvas);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.workspace.on("canvas:selection-menu", (menu, canvas) => {
        menu.addItem((item) => {
          item.setTitle("Add icon here").setIcon("plus-circle").onClick(() => {
            this.openIconPicker(canvas);
          });
        });
      })
    );
    this.registerDomEvent(document, "contextmenu", (evt) => {
      const target = evt.target;
      if (target.closest(".canvas-wrapper")) {
        const canvasView = this.getActiveCanvasView();
        if (canvasView && !target.closest(".canvas-node")) {
          setTimeout(() => {
            const menu = document.querySelector(".menu:not(.canvas-icons-menu-added)");
            if (menu) {
              menu.classList.add("canvas-icons-menu-added");
              const menuItem = menu.createEl("div", { cls: "menu-item" });
              menuItem.createEl("div", { cls: "menu-item-icon" });
              (0, import_obsidian.setIcon)(menuItem.querySelector(".menu-item-icon"), "plus-circle");
              menuItem.createEl("div", { cls: "menu-item-title", text: "Add icon" });
              menuItem.addEventListener("click", () => {
                const canvas = canvasView.canvas;
                const rect = canvasView.contentEl.getBoundingClientRect();
                const x = (evt.clientX - rect.left - canvas.tx) / canvas.tZoom;
                const y = (evt.clientY - rect.top - canvas.ty) / canvas.tZoom;
                this.openIconPicker(canvas, x, y);
                menu.remove();
              });
            }
          }, 10);
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.addToolbarButton();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        setTimeout(() => this.addToolbarButton(), 100);
      })
    );
    const dblClickHandler = (evt) => {
      const target = evt.target;
      const iconContainer = target.closest(".canvas-icon-container");
      if (iconContainer) {
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        const canvasNode = target.closest(".canvas-node");
        if (canvasNode) {
          const nodeId = canvasNode.getAttribute("data-node-id");
          if (nodeId) {
            const canvasView = this.getActiveCanvasView();
            if (canvasView) {
              this.openIconPickerForEdit(canvasView.canvas, nodeId);
            }
          }
        }
      }
    };
    document.addEventListener("dblclick", dblClickHandler, { capture: true });
    this.register(() => document.removeEventListener("dblclick", dblClickHandler, { capture: true }));
    this.addSettingTab(new CanvasIconsSettingTab(this.app, this));
  }
  addToolbarButton() {
    const canvasView = this.getActiveCanvasView();
    if (!canvasView) {
      return;
    }
    const toolbar = canvasView.contentEl.querySelector(".canvas-card-menu");
    if (!toolbar) {
      return;
    }
    if (toolbar.querySelector(".canvas-icons-toolbar-btn")) {
      return;
    }
    const button = document.createElement("div");
    button.className = "canvas-card-menu-button mod-draggable canvas-icons-toolbar-btn";
    button.setAttribute("aria-label", "Add icon");
    button.setAttribute("data-tooltip-position", "top");
    (0, import_obsidian.setIcon)(button, "smile-plus");
    button.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openIconPicker(canvasView.canvas);
    });
    toolbar.appendChild(button);
    this.toolbarButton = button;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getActiveCanvasView() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    if (view && view.getViewType() === "canvas") {
      return view;
    }
    return null;
  }
  openIconPicker(canvas, x, y) {
    new IconPickerModal(this.app, this, canvas, x, y).open();
  }
  openIconPickerForEdit(canvas, nodeId) {
    var _a;
    const data = canvas.getData();
    const node = data.nodes.find((n) => n.id === nodeId);
    if (node && ((_a = node.text) == null ? void 0 : _a.includes("canvas-icon-container"))) {
      new IconPickerModal(this.app, this, canvas, void 0, void 0, nodeId).open();
    }
  }
  addRecentIcon(iconId) {
    this.settings.recentIcons = this.settings.recentIcons.filter((id) => id !== iconId);
    this.settings.recentIcons.unshift(iconId);
    if (this.settings.recentIcons.length > this.settings.maxRecentIcons) {
      this.settings.recentIcons = this.settings.recentIcons.slice(0, this.settings.maxRecentIcons);
    }
    this.saveSettings();
  }
};
var IconPickerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, canvas, x, y, editNodeId) {
    super(app);
    this.plugin = plugin;
    this.canvas = canvas;
    this.x = x;
    this.y = y;
    this.editNodeId = editNodeId;
    this.allIcons = (0, import_obsidian.getIconIds)();
    this.filteredIcons = this.allIcons;
    this.selectedSize = plugin.settings.iconSize;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("canvas-icons-modal");
    const title = this.editNodeId ? "Change icon" : "Choose an icon";
    contentEl.createEl("h2", { text: title });
    const controlsContainer = contentEl.createDiv({ cls: "canvas-icons-controls" });
    const searchContainer = controlsContainer.createDiv({ cls: "canvas-icons-search" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search icons...",
      cls: "canvas-icons-search-input"
    });
    this.searchInput.focus();
    this.searchInput.addEventListener("input", () => this.filterIcons());
    if (!this.editNodeId) {
      const settingsContainer = controlsContainer.createDiv({ cls: "canvas-icons-settings" });
      const sizeContainer = settingsContainer.createDiv({ cls: "canvas-icons-size" });
      sizeContainer.createEl("label", { text: "Size:" });
      const sizeInput = sizeContainer.createEl("input", {
        type: "range",
        cls: "canvas-icons-size-input"
      });
      sizeInput.min = "32";
      sizeInput.max = "256";
      sizeInput.value = String(this.selectedSize);
      const sizeLabel = sizeContainer.createEl("span", {
        text: `${this.selectedSize}px`,
        cls: "canvas-icons-size-label"
      });
      sizeInput.addEventListener("input", () => {
        this.selectedSize = parseInt(sizeInput.value);
        sizeLabel.textContent = `${this.selectedSize}px`;
      });
      const colorHint = settingsContainer.createDiv({ cls: "canvas-icons-color-hint" });
      colorHint.createEl("span", {
        text: "Tip: Use Canvas color picker to change icon color",
        cls: "canvas-icons-hint-text"
      });
    }
    if (this.plugin.settings.recentIcons.length > 0) {
      const recentSection = contentEl.createDiv({ cls: "canvas-icons-section" });
      recentSection.createEl("h3", { text: "Recent" });
      const recentGrid = recentSection.createDiv({ cls: "canvas-icons-grid canvas-icons-grid-recent" });
      this.plugin.settings.recentIcons.forEach((iconId) => {
        this.createIconButton(recentGrid, iconId);
      });
    }
    const popularSection = contentEl.createDiv({ cls: "canvas-icons-section" });
    popularSection.createEl("h3", { text: "Popular" });
    const popularGrid = popularSection.createDiv({ cls: "canvas-icons-grid canvas-icons-grid-popular" });
    POPULAR_ICONS.forEach((iconId) => {
      if (this.allIcons.includes(iconId)) {
        this.createIconButton(popularGrid, iconId);
      }
    });
    const allSection = contentEl.createDiv({ cls: "canvas-icons-section canvas-icons-section-all" });
    allSection.createEl("h3", { text: "All icons" });
    this.iconGrid = allSection.createDiv({ cls: "canvas-icons-grid" });
    this.renderIcons();
  }
  createIconButton(container, iconId) {
    const iconBtn = container.createEl("button", {
      cls: "canvas-icons-icon-btn",
      attr: { "aria-label": iconId, "title": iconId }
    });
    const iconWrapper = iconBtn.createDiv({ cls: "canvas-icons-icon-wrapper" });
    (0, import_obsidian.setIcon)(iconWrapper, iconId);
    iconBtn.addEventListener("click", () => {
      this.insertIcon(iconId);
    });
    return iconBtn;
  }
  filterIcons() {
    const query = this.searchInput.value.toLowerCase().trim();
    if (query === "") {
      this.filteredIcons = this.allIcons;
    } else {
      this.filteredIcons = this.allIcons.filter(
        (icon) => icon.toLowerCase().includes(query)
      );
    }
    this.renderIcons();
  }
  renderIcons() {
    this.iconGrid.empty();
    const maxIcons = 200;
    const iconsToRender = this.filteredIcons.slice(0, maxIcons);
    iconsToRender.forEach((iconId) => {
      this.createIconButton(this.iconGrid, iconId);
    });
    if (this.filteredIcons.length > maxIcons) {
      this.iconGrid.createEl("div", {
        cls: "canvas-icons-more",
        text: `...and ${this.filteredIcons.length - maxIcons} more. Use search to find specific icons.`
      });
    }
    if (this.filteredIcons.length === 0) {
      this.iconGrid.createEl("div", {
        cls: "canvas-icons-empty",
        text: "No icons found"
      });
    }
  }
  insertIcon(iconId) {
    var _a, _b;
    const tempDiv = document.createElement("div");
    (0, import_obsidian.setIcon)(tempDiv, iconId);
    const svg = tempDiv.querySelector("svg");
    if (!svg) {
      new import_obsidian.Notice("Failed to get icon");
      return;
    }
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", "currentColor");
    svg.style.maxWidth = "100%";
    svg.style.maxHeight = "100%";
    svg.style.objectFit = "contain";
    const svgString = svg.outerHTML;
    const htmlContent = `<div class="canvas-icon-container" style="display:flex;align-items:center;justify-content:center;width:100%;height:100%;box-sizing:border-box;">${svgString}</div>`;
    try {
      const data = this.canvas.getData();
      if (this.editNodeId) {
        const nodeIndex = data.nodes.findIndex((n) => n.id === this.editNodeId);
        if (nodeIndex !== -1) {
          data.nodes[nodeIndex].text = htmlContent;
          this.canvas.setData(data);
          this.canvas.requestSave();
          this.plugin.addRecentIcon(iconId);
          new import_obsidian.Notice(`Changed icon to: ${iconId}`);
        } else {
          new import_obsidian.Notice("Node not found");
        }
      } else {
        let posX = (_a = this.x) != null ? _a : this.canvas.x;
        let posY = (_b = this.y) != null ? _b : this.canvas.y;
        if (this.x === void 0 || this.y === void 0) {
          const canvasView = this.plugin.getActiveCanvasView();
          if (canvasView) {
            const rect = canvasView.contentEl.getBoundingClientRect();
            posX = (-this.canvas.tx + rect.width / 2) / this.canvas.tZoom - this.selectedSize / 2;
            posY = (-this.canvas.ty + rect.height / 2) / this.canvas.tZoom - this.selectedSize / 2;
          }
        }
        const newNode = {
          id: this.generateId(),
          type: "text",
          text: htmlContent,
          x: posX,
          y: posY,
          width: this.selectedSize,
          height: this.selectedSize
          // Не устанавливаем color - используется стандартный Canvas color picker
        };
        data.nodes.push(newNode);
        this.canvas.setData(data);
        this.canvas.requestSave();
        this.plugin.addRecentIcon(iconId);
        new import_obsidian.Notice(`Added icon: ${iconId}`);
      }
    } catch (err) {
      console.error("Failed to add/edit icon:", err);
      new import_obsidian.Notice("Failed to add/edit icon");
    }
    this.close();
  }
  generateId() {
    return Math.random().toString(36).substring(2, 18);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CanvasIconsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Canvas Icons Settings" });
    new import_obsidian.Setting(containerEl).setName("Default icon size").setDesc("Default size for new icons (in pixels)").addSlider((slider) => slider.setLimits(32, 256, 8).setValue(this.plugin.settings.iconSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.iconSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Maximum recent icons").setDesc("How many recent icons to remember").addSlider((slider) => slider.setLimits(5, 50, 5).setValue(this.plugin.settings.maxRecentIcons).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxRecentIcons = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Clear recent icons").setDesc("Remove all recently used icons from the list").addButton((button) => button.setButtonText("Clear").onClick(async () => {
      this.plugin.settings.recentIcons = [];
      await this.plugin.saveSettings();
      new import_obsidian.Notice("Recent icons cleared");
    }));
  }
};
